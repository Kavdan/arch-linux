## **1. UDP сохраняет границы сообщений**  
### **Основное отличие от TCP**  
- **TCP** — это потоковый протокол. Данные передаются как непрерывный поток байтов, без явных границ между сообщениями.  
- **UDP** — дейтаграммный протокол. Каждый вызов `send()` соответствует **ровно одному** вызову `receive()`.  

### **Что это значит?**  
- Если клиент отправляет 3 UDP-пакета:  
  ```text
  [Пакет1] [Пакет2] [Пакет3]
  ```  
  Сервер **никогда** не получит их "слипшимися" в один вызов `receive()`. Каждый `receive()` вернёт только один пакет.  

### **Пример**  
```java
DatagramSocket socket = new DatagramSocket(1234);
DatagramPacket packet = new DatagramPacket(new byte[1024], 1024);

// Клиент отправил: "Hello" и "World"
socket.receive(packet); // Получит "Hello"
socket.receive(packet); // Получит "World"
```  

---

## **2. UDP не буферизует данные для повторной отправки**  
### **Поведение TCP**  
- Когда вы вызываете `write()` в TCP, данные копируются в буфер ядра. Они **могут быть отправлены не сразу**.  
- TCP гарантирует доставку, поэтому буферизует данные на случай потерь и повторной передачи.  

### **Поведение UDP**  
- Вызов `send()` означает, что данные **немедленно переданы сетевому стеку**.  
- UDP **не гарантирует доставку** и не хранит копии данных для повтора.  

---

## **3. Очередь полученных сообщений в UDP**  
### **Как работает `receive()`?**  
- Пришедшие UDP-пакеты попадают в **FIFO-очередь**.  
- Каждый вызов `receive()` забирает **одно сообщение** из очереди.  

### **Важные нюансы**  
1. **Размер буфера имеет значение**  
   - Если буфер `DatagramPacket` меньше, чем полученное сообщение, **лишние байты теряются без предупреждения**.  
   - **Решение:** Всегда используйте буфер достаточного размера (например, 65,600 байт — максимум для UDP).  

2. **Сброс длины пакета**  
   После `receive()` внутренний размер `DatagramPacket` меняется на длину полученного сообщения.  
   **Перед повторным использованием пакета нужно сбросить длину:**  
   ```java
   packet.setLength(buffer.length); // Важно!
   socket.receive(packet);
   ```  

3. **Метод `getData()` возвращает весь буфер**  
   - Даже если в пакет записано только 10 байт, `getData()` вернёт **весь исходный массив**.  
   - Чтобы извлечь только полученные данные, используйте:  
     ```java
     byte[] receivedData = Arrays.copyOfRange(
         packet.getData(),
         packet.getOffset(),
         packet.getOffset() + packet.getLength()
     );
     ```  

---

## **4. Пример из текста**  
### **Ситуация**  
- Исходный буфер `buf`: 20 байт (индексы 0–19).  
- `DatagramPacket` настроен на средние 10 байт (`buf[5..14]`).  
- Пришло сообщение из 8 байт: `[41, 42, 43, 44, 45, 46, 47, 48]`.  

### **Что происходит?**  
1. Данные записываются в `buf`, начиная с позиции 5:  
   ```text
   До:   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
   После: [0,1,2,3,4,41,42,43,44,45,46,47,48,13,14,15,16,17,18,19]
   ```  
2. `getData()` вернёт весь `buf`, а не только полученные байты.  

### **Как правильно извлечь данные**  
```java
byte[] cleanData = Arrays.copyOfRange(
    packet.getData(),
    packet.getOffset(),
    packet.getOffset() + packet.getLength()
);
// cleanData = [41,42,43,44,45,46,47,48]
```  

---

## **Вывод**  
- **UDP сохраняет границы сообщений** — один `send()` = один `receive()`.  
- **Всегда используйте буфер достаточного размера** (до 65,507 байт).  
- **Сбрасывайте длину пакета** перед повторным `receive()`.  
- **Аккуратно извлекайте данные** из `DatagramPacket`, учитывая смещение и длину.  

Эти особенности делают UDP простым, но требующим внимания к деталям.